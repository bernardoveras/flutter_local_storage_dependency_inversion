# SOLID Dependency Inversion Principle Example

This project is a practical example of the Dependency Inversion Principle, also known as "D" of SOLID.

[![en](https://img.shields.io/badge/lang-en-red.svg)](https://github.com/bernardoveras/flutter_local_storage_dependency_inversion/blob/main/README.md)
[![pt-br](https://img.shields.io/badge/lang-pt--br-green.svg)](https://github.com/bernardoveras/flutter_local_storage_dependency_inversion/blob/main/README.pt_BR.md)
[![es](https://img.shields.io/badge/lang-es-yellow.svg)](https://github.com/bernardoveras/flutter_local_storage_dependency_inversion/blob/main/README.es.md)

## What is SOLID

SOLID is an acronym for five software design principles aimed at helping create high-quality, maintainable and scalable software. These principles are:

- Single Responsibility Principle (SRP)
- Open/Closed Principle (OCP)
- Liskov Substitution Principle (LSP)
- Interface Segregation Principle (ISP)
- Dependency Inversion Principle (DIP)

## What is the Dependency Inversion Principle

The Dependency Inversion Principle is one of the SOLID principles that states that high-level classes should not depend on low-level classes, but both should depend on abstractions. In other words, dependencies should be inverted, where high-level classes depend on interfaces, not concrete classes.

## Why use the Dependency Inversion Principle

By following the Dependency Inversion Principle, you ensure that your code is cleaner and easier to maintain, as dependencies become clear and decoupled, making future changes easier. Additionally, your code becomes more scalable and testable.

## How to use the Dependency Inversion Principle in your project

To use the Dependency Inversion Principle in your project, you need to create interfaces for your low-level classes and make high-level classes depend on these interfaces. This ensures that dependencies are clear and decoupled, making future changes easier.

## Conclusion

The Dependency Inversion Principle is one of the SOLID principles that helps create high-quality, maintainable and scalable software. By following this principle, you ensure that your code is cleaner and easier to maintain, as well as more scalable and testable. Therefore, it is a good practice to include this principle in your project.
